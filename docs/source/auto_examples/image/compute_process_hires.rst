
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/image/compute_process_hires.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/theislab/squidpy_notebooks/master?filepath=docs/source/auto_examples/image/compute_process_hires.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_image_compute_process_hires.py:

Process a high-resolution image
-------------------------------

This example shows how to use :func:`squidpy.im.process` with tiling.

The function can be applied to any method (e.g., smoothing, conversion to grayscale)
or ``layer`` of a high-resolution image layer of :class:`squidpy.im.ImageContainer`.

By default, :func:`squidpy.im.process` processes the entire input image at once.
In the case of high-resolution tissue slides however, the images might be too big to fit in memory
and cannot be processed at once.
In that case you can use the argument ``chunks`` to tile the image in crops of shape ``chunks``,
process each crop, and re-assemble the resulting image.
Note that you can also use :func:`squidpy.im.segment` in this manner.

Note that depending on the processing function used, there might be border effects occurring at the edges
of the crops.
Since Squidpy is backed by :mod:`dask`, and internally chunking is done using :func:`dask.array.map_overlap`,
dealing with these border effects is easy.
Just specify the ``depth`` and ``boundary`` arguments in the ``apply_kwargs``
upon the call to :func:`squidpy.im.process`.
For more information, please refer to the documentation of :func:`dask.array.map_overlap`.

For the build in processing functions, `gray` and `smooth`, the border effects are already automatically
taken care of, so it is not necessary to specify ``depth`` and ``boundary``.
For :func:`squidpy.im.segment`, the default ``depth`` is 30, which already takes care of most severe
border effects.

.. seealso::

    - :ref:`sphx_glr_auto_examples_image_compute_smooth.py`.
    - :ref:`sphx_glr_auto_examples_image_compute_gray.py`.
    - :ref:`sphx_glr_auto_examples_image_compute_segment_fluo.py`.

.. GENERATED FROM PYTHON SOURCE LINES 37-45

.. code-block:: default


    import squidpy as sq

    from scipy.ndimage import gaussian_filter
    import numpy as np

    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 46-48

Built-in processing functions
+++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 48-52

.. code-block:: default


    # load the H&E stained tissue image
    img = sq.datasets.visium_hne_image()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0.00/380M [00:00<?, ?B/s]      0%|          | 56.0k/380M [00:00<16:09, 411kB/s]      0%|          | 248k/380M [00:00<06:43, 986kB/s]       0%|          | 0.99M/380M [00:00<02:09, 3.07MB/s]      1%|1         | 4.00M/380M [00:00<00:37, 10.6MB/s]      3%|2         | 9.69M/380M [00:00<00:17, 22.0MB/s]      4%|4         | 15.3M/380M [00:00<00:13, 28.7MB/s]      6%|5         | 20.9M/380M [00:00<00:11, 32.8MB/s]      7%|7         | 26.6M/380M [00:01<00:10, 35.7MB/s]      9%|8         | 32.4M/380M [00:01<00:09, 38.0MB/s]     10%|#         | 38.1M/380M [00:01<00:09, 39.2MB/s]     12%|#1        | 43.9M/380M [00:01<00:08, 40.3MB/s]     13%|#3        | 49.7M/380M [00:01<00:08, 41.1MB/s]     15%|#4        | 55.6M/380M [00:01<00:08, 41.8MB/s]     16%|#6        | 61.4M/380M [00:01<00:07, 42.1MB/s]     18%|#7        | 67.2M/380M [00:02<00:07, 42.4MB/s]     19%|#9        | 73.1M/380M [00:02<00:07, 42.7MB/s]     21%|##        | 79.0M/380M [00:02<00:07, 42.9MB/s]     22%|##2       | 84.8M/380M [00:02<00:07, 42.9MB/s]     24%|##3       | 90.8M/380M [00:02<00:07, 42.9MB/s]     25%|##5       | 96.6M/380M [00:02<00:06, 43.5MB/s]     27%|##6       | 102M/380M [00:02<00:06, 43.3MB/s]      28%|##8       | 108M/380M [00:03<00:06, 43.0MB/s]     30%|###       | 114M/380M [00:03<00:06, 43.4MB/s]     32%|###1      | 120M/380M [00:03<00:06, 43.3MB/s]     33%|###3      | 126M/380M [00:03<00:06, 43.5MB/s]     35%|###4      | 132M/380M [00:03<00:05, 43.4MB/s]     36%|###6      | 138M/380M [00:03<00:05, 43.5MB/s]     38%|###7      | 143M/380M [00:03<00:05, 43.3MB/s]     39%|###9      | 149M/380M [00:04<00:05, 43.2MB/s]     41%|####      | 155M/380M [00:04<00:05, 43.3MB/s]     42%|####2     | 160M/380M [00:04<00:05, 45.9MB/s]     43%|####3     | 164M/380M [00:04<00:05, 42.6MB/s]     44%|####4     | 169M/380M [00:04<00:04, 45.1MB/s]     45%|####5     | 173M/380M [00:04<00:05, 42.3MB/s]     47%|####6     | 178M/380M [00:04<00:04, 44.5MB/s]     48%|####7     | 181M/380M [00:04<00:04, 42.0MB/s]     49%|####9     | 186M/380M [00:04<00:04, 44.5MB/s]     50%|#####     | 190M/380M [00:05<00:04, 41.8MB/s]     51%|#####1    | 194M/380M [00:05<00:04, 42.2MB/s]     52%|#####2    | 199M/380M [00:05<00:04, 42.2MB/s]     53%|#####3    | 203M/380M [00:05<00:04, 43.3MB/s]     55%|#####4    | 207M/380M [00:05<00:04, 41.5MB/s]     56%|#####5    | 211M/380M [00:05<00:04, 41.7MB/s]     57%|#####6    | 216M/380M [00:05<00:04, 42.4MB/s]     58%|#####7    | 220M/380M [00:05<00:03, 42.6MB/s]     59%|#####9    | 225M/380M [00:05<00:03, 42.6MB/s]     60%|######    | 229M/380M [00:06<00:03, 42.4MB/s]     61%|######1   | 233M/380M [00:06<00:03, 43.1MB/s]     62%|######2   | 237M/380M [00:06<00:03, 42.2MB/s]     64%|######3   | 242M/380M [00:06<00:03, 43.4MB/s]     65%|######4   | 246M/380M [00:06<00:03, 41.9MB/s]     66%|######6   | 251M/380M [00:06<00:03, 43.6MB/s]     67%|######6   | 254M/380M [00:06<00:03, 41.9MB/s]     68%|######8   | 259M/380M [00:06<00:02, 43.3MB/s]     69%|######9   | 263M/380M [00:06<00:02, 41.5MB/s]     71%|#######   | 268M/380M [00:07<00:02, 43.0MB/s]     71%|#######1  | 272M/380M [00:07<00:02, 41.5MB/s]     73%|#######2  | 277M/380M [00:07<00:02, 43.5MB/s]     74%|#######3  | 280M/380M [00:07<00:02, 42.0MB/s]     75%|#######5  | 286M/380M [00:07<00:02, 43.9MB/s]     76%|#######6  | 289M/380M [00:07<00:02, 41.8MB/s]     77%|#######7  | 294M/380M [00:07<00:02, 43.8MB/s]     78%|#######8  | 298M/380M [00:07<00:02, 41.5MB/s]     80%|#######9  | 303M/380M [00:07<00:01, 44.1MB/s]     81%|########  | 306M/380M [00:07<00:01, 41.3MB/s]     82%|########1 | 311M/380M [00:08<00:01, 43.5MB/s]     83%|########2 | 315M/380M [00:08<00:01, 41.2MB/s]     84%|########4 | 320M/380M [00:08<00:01, 43.5MB/s]     85%|########5 | 324M/380M [00:08<00:01, 41.9MB/s]     87%|########6 | 329M/380M [00:08<00:01, 43.7MB/s]     87%|########7 | 332M/380M [00:08<00:01, 42.2MB/s]     89%|########8 | 337M/380M [00:08<00:01, 43.7MB/s]     90%|########9 | 341M/380M [00:08<00:00, 42.1MB/s]     91%|#########1| 346M/380M [00:08<00:00, 43.6MB/s]     92%|#########2| 350M/380M [00:09<00:00, 42.0MB/s]     93%|#########3| 355M/380M [00:09<00:00, 43.6MB/s]     94%|#########4| 359M/380M [00:09<00:00, 42.7MB/s]     96%|#########5| 364M/380M [00:09<00:00, 43.6MB/s]     97%|#########6| 367M/380M [00:09<00:00, 42.6MB/s]     98%|#########7| 372M/380M [00:09<00:00, 43.0MB/s]     99%|#########8| 376M/380M [00:09<00:00, 42.4MB/s]    100%|##########| 380M/380M [00:09<00:00, 40.9MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 53-54

We will process the image by tiling it in crops of shape ``chunks = (1000, 1000)``.

.. GENERATED FROM PYTHON SOURCE LINES 54-56

.. code-block:: default

    sq.im.process(img, layer="image", method="gray", chunks=1000)








.. GENERATED FROM PYTHON SOURCE LINES 57-58

Now we can look at the result on a cropped part of the image.

.. GENERATED FROM PYTHON SOURCE LINES 58-66

.. code-block:: default

    crop = img.crop_corner(4000, 4000, size=2000)

    fig, axes = plt.subplots(1, 2)
    crop.show("image", ax=axes[0])
    _ = axes[0].set_title("original")
    crop.show("image_gray", cmap="gray", ax=axes[1])
    _ = axes[1].set_title("grayscale")




.. image-sg:: /auto_examples/image/images/sphx_glr_compute_process_hires_001.png
   :alt: original, grayscale
   :srcset: /auto_examples/image/images/sphx_glr_compute_process_hires_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 67-74

Custom processing functions
+++++++++++++++++++++++++++
Here, we use a custom processing function (here :func:`scipy.ndimage.gaussian_filter`)
with chunking to showcase the ``depth`` and ``boundary`` arguments.

Lets use a simple image and choose the chunk size in such a way to clearly see the differences
between using overlapping crops and non-overlapping crops.

.. GENERATED FROM PYTHON SOURCE LINES 74-98

.. code-block:: default

    arr = np.zeros((20, 20))
    arr[10:] = 1
    img = sq.im.ImageContainer(arr, layer="image")

    # smooth the image using `depth` 0 and 1
    sq.im.process(
        img,
        layer="image",
        method=gaussian_filter,
        layer_added="smooth_depth0",
        chunks=10,
        sigma=1,
        apply_kwargs={"depth": 0},
    )
    sq.im.process(
        img,
        layer="image",
        method=gaussian_filter,
        layer_added="smooth_depth1",
        chunks=10,
        sigma=1,
        apply_kwargs={"depth": 1, "boundary": "reflect"},
    )








.. GENERATED FROM PYTHON SOURCE LINES 99-101

Plot the difference in results.
Using overlapping blocks with ``depth = 1`` removes the artifacts at the borders between chunks.

.. GENERATED FROM PYTHON SOURCE LINES 101-108

.. code-block:: default

    fig, axes = plt.subplots(1, 3)
    img.show("image", ax=axes[0])
    _ = axes[0].set_title("original")
    img.show("smooth_depth0", ax=axes[1])
    _ = axes[1].set_title("non-overlapping crops")
    img.show("smooth_depth1", ax=axes[2])
    _ = axes[2].set_title("overlapping crops")



.. image-sg:: /auto_examples/image/images/sphx_glr_compute_process_hires_002.png
   :alt: original, non-overlapping crops, overlapping crops
   :srcset: /auto_examples/image/images/sphx_glr_compute_process_hires_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  21.892 seconds)

**Estimated memory usage:**  2250 MB


.. _sphx_glr_download_auto_examples_image_compute_process_hires.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: compute_process_hires.py <compute_process_hires.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: compute_process_hires.ipynb <compute_process_hires.ipynb>`
