
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_fouri.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/theislab/squidpy_notebooks/master?filepath=docs/source/auto_tutorials/tutorial_fouri.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_fouri.py:

Analyze 4i data
===============

This tutorial shows how to apply Squidpy for the analysis of 4i data.

The data used here was obtained from :cite:`Gut2018-ap`.
We provide a pre-processed subset of the data, in :class:`anndata.AnnData` format.
For details on how it was pre-processed, please refer to the original paper.

.. seealso::

    See :ref:`sphx_glr_auto_tutorials_tutorial_imc.py` for additional analysis examples.

Import packages & data
----------------------
To run the notebook locally, create a conda environment as *conda env create -f environment.yml* using this
`environment.yml <https://github.com/theislab/squidpy_notebooks/blob/master/environment.yml>`_

.. GENERATED FROM PYTHON SOURCE LINES 21-31

.. code-block:: default


    import scanpy as sc
    import squidpy as sq

    sc.logging.print_header()
    print(f"squidpy=={sq.__version__}")

    # load the pre-processed dataset
    adata = sq.datasets.four_i()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    scanpy==1.8.0.dev93+g4dd8de9e anndata==0.7.6 umap==0.5.1 numpy==1.20.3 scipy==1.6.3 pandas==1.2.4 scikit-learn==0.24.2 statsmodels==0.12.2 python-igraph==0.9.6 pynndescent==0.5.2
    squidpy==1.0.0
      0%|          | 0.00/173M [00:00<?, ?B/s]      0%|          | 24.0k/173M [00:00<15:21, 197kB/s]      0%|          | 56.0k/173M [00:00<12:54, 234kB/s]      0%|          | 88.0k/173M [00:00<12:18, 246kB/s]      0%|          | 208k/173M [00:00<05:39, 534kB/s]       0%|          | 464k/173M [00:00<02:46, 1.09MB/s]      1%|          | 936k/173M [00:00<01:29, 2.02MB/s]      1%|1         | 1.84M/173M [00:00<00:46, 3.89MB/s]      2%|2         | 3.73M/173M [00:01<00:23, 7.62MB/s]      4%|3         | 6.37M/173M [00:01<00:14, 12.1MB/s]      5%|5         | 9.35M/173M [00:01<00:10, 16.0MB/s]      7%|7         | 12.3M/173M [00:01<00:09, 18.5MB/s]      8%|8         | 14.4M/173M [00:01<00:09, 18.2MB/s]     10%|9         | 17.2M/173M [00:01<00:08, 19.8MB/s]     12%|#1        | 20.1M/173M [00:01<00:07, 21.0MB/s]     13%|#3        | 23.0M/173M [00:01<00:07, 21.9MB/s]     15%|#4        | 25.9M/173M [00:02<00:06, 22.3MB/s]     16%|#6        | 28.5M/173M [00:02<00:06, 22.2MB/s]     18%|#8        | 31.4M/173M [00:02<00:06, 22.7MB/s]     20%|#9        | 34.3M/173M [00:02<00:06, 23.2MB/s]     22%|##1       | 37.3M/173M [00:02<00:06, 23.6MB/s]     23%|##3       | 40.2M/173M [00:02<00:05, 23.9MB/s]     25%|##4       | 43.1M/173M [00:02<00:05, 23.8MB/s]     27%|##6       | 45.9M/173M [00:02<00:05, 23.8MB/s]     28%|##8       | 48.8M/173M [00:03<00:05, 23.8MB/s]     30%|##9       | 51.7M/173M [00:03<00:05, 23.8MB/s]     32%|###1      | 54.6M/173M [00:03<00:05, 24.0MB/s]     33%|###3      | 57.5M/173M [00:03<00:05, 23.9MB/s]     35%|###4      | 60.4M/173M [00:03<00:04, 24.0MB/s]     37%|###6      | 63.4M/173M [00:03<00:04, 24.1MB/s]     38%|###8      | 66.3M/173M [00:03<00:04, 24.1MB/s]     40%|###9      | 69.2M/173M [00:03<00:04, 24.1MB/s]     42%|####1     | 72.1M/173M [00:04<00:04, 24.2MB/s]     43%|####3     | 75.1M/173M [00:04<00:04, 24.3MB/s]     45%|####5     | 78.0M/173M [00:04<00:04, 24.3MB/s]     47%|####6     | 81.0M/173M [00:04<00:03, 24.3MB/s]     48%|####8     | 83.9M/173M [00:04<00:03, 24.4MB/s]     50%|#####     | 86.9M/173M [00:04<00:03, 24.4MB/s]     52%|#####1    | 89.8M/173M [00:04<00:03, 24.4MB/s]     54%|#####3    | 92.8M/173M [00:04<00:03, 24.4MB/s]     55%|#####5    | 95.7M/173M [00:05<00:03, 24.4MB/s]     57%|#####6    | 98.6M/173M [00:05<00:03, 24.4MB/s]     59%|#####8    | 101M/173M [00:05<00:03, 24.2MB/s]      60%|######    | 104M/173M [00:05<00:02, 24.3MB/s]     62%|######2   | 107M/173M [00:05<00:02, 24.2MB/s]     64%|######3   | 110M/173M [00:05<00:02, 24.3MB/s]     65%|######5   | 113M/173M [00:05<00:02, 24.3MB/s]     67%|######7   | 116M/173M [00:05<00:02, 24.5MB/s]     69%|######8   | 119M/173M [00:06<00:02, 24.6MB/s]     71%|#######   | 122M/173M [00:06<00:02, 24.6MB/s]     72%|#######2  | 125M/173M [00:06<00:02, 24.6MB/s]     74%|#######3  | 128M/173M [00:06<00:01, 24.4MB/s]     76%|#######5  | 131M/173M [00:06<00:01, 24.3MB/s]     77%|#######7  | 134M/173M [00:06<00:01, 24.3MB/s]     79%|#######8  | 137M/173M [00:06<00:01, 24.2MB/s]     81%|########  | 140M/173M [00:06<00:01, 24.3MB/s]     82%|########2 | 143M/173M [00:07<00:01, 24.2MB/s]     84%|########4 | 146M/173M [00:07<00:01, 24.3MB/s]     86%|########5 | 149M/173M [00:07<00:01, 24.1MB/s]     88%|########7 | 151M/173M [00:07<00:00, 24.5MB/s]     89%|########9 | 154M/173M [00:07<00:00, 24.5MB/s]     91%|######### | 157M/173M [00:07<00:00, 24.5MB/s]     93%|#########2| 160M/173M [00:07<00:00, 24.5MB/s]     94%|#########4| 163M/173M [00:07<00:00, 24.4MB/s]     96%|#########5| 165M/173M [00:08<00:00, 20.7MB/s]     97%|#########7| 168M/173M [00:08<00:00, 21.9MB/s]     98%|#########8| 170M/173M [00:08<00:00, 20.3MB/s]    100%|##########| 173M/173M [00:08<00:00, 21.6MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 32-34

First, let's visualize cluster annotation in spatial context
with :func:`scanpy.pl.spatial`.

.. GENERATED FROM PYTHON SOURCE LINES 34-37

.. code-block:: default

    sc.pl.spatial(adata, color="cluster", spot_size=1)





.. image:: /auto_tutorials/images/sphx_glr_tutorial_fouri_001.png
    :alt: cluster
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 38-58

Neighborhood enrichment analysis
--------------------------------
Similar to other spatial data, we can investigate spatial organization of clusters
in a quantitative way, by computing a neighborhood enrichment score.
You can compute such score with the following function: :func:`squidpy.gr.nhood_enrichment`.
In short, it's an enrichment score on spatial proximity of clusters:
if spots belonging to two different clusters are often close to each other,
then they will have a high score and can be defined as being *enriched*.
On the other hand, if they are far apart, the score will be low
and they can be defined as *depleted*.
This score is based on a permutation-based test, and you can set
the number of permutations with the `n_perms` argument (default is 1000).

Since the function works on a connectivity matrix, we need to compute that as well.
This can be done with :func:`squidpy.gr.spatial_neighbors`.
Please see :ref:`sphx_glr_auto_examples_graph_compute_spatial_neighbors.py` for more details
of how this function works.

Finally, we'll directly visualize the results with :func:`squidpy.pl.nhood_enrichment`.
We'll add a dendrogram to the heatmap computed with linkage method *ward*.

.. GENERATED FROM PYTHON SOURCE LINES 58-63

.. code-block:: default

    sq.gr.spatial_neighbors(adata, coord_type="generic")
    sq.gr.nhood_enrichment(adata, cluster_key="cluster")
    sq.pl.nhood_enrichment(adata, cluster_key="cluster", method="ward", vmin=-100, vmax=100)





.. image:: /auto_tutorials/images/sphx_glr_tutorial_fouri_002.png
    :alt: Neighborhood enrichment
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/1000 [00:00<?, ?/s]
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/squidpy/pl/_utils.py:573: MatplotlibDeprecationWarning: In a future version, 'pad' will default to rcParams['figure.subplot.hspace'].  Set pad=0 to keep the old behavior.
      col_ax = divider.append_axes("top", size="5%")




.. GENERATED FROM PYTHON SOURCE LINES 64-68

A similar analysis can be performed with :func:`squidpy.gr.interaction_matrix`.
The function computes the number of shared edges in the neighbor graph between clusters.
Please see :ref:`sphx_glr_auto_examples_graph_compute_interaction_matrix.py` for more details
of how this function works.

.. GENERATED FROM PYTHON SOURCE LINES 68-72

.. code-block:: default

    sq.gr.interaction_matrix(adata, cluster_key="cluster")
    sq.pl.interaction_matrix(adata, cluster_key="cluster", method="ward", vmax=20000)





.. image:: /auto_tutorials/images/sphx_glr_tutorial_fouri_003.png
    :alt: Interaction matrix
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/squidpy/pl/_utils.py:573: MatplotlibDeprecationWarning: In a future version, 'pad' will default to rcParams['figure.subplot.hspace'].  Set pad=0 to keep the old behavior.
      col_ax = divider.append_axes("top", size="5%")




.. GENERATED FROM PYTHON SOURCE LINES 73-88

Additional analyses to gain quantitative understanding of spatial patterning of
sub-cellular observations are:
- :ref:`sphx_glr_auto_examples_graph_compute_ripley.py` for Ripley's statistics.
- :ref:`sphx_glr_auto_examples_graph_compute_co_occurrence.py` for co-occurrence score.

Spatially variable genes with spatial autocorrelation statistics
----------------------------------------------------------------
With Squidpy we can investigate spatial variability of gene expression.
This is an example of a function that only supports 2D data.
:func:`squidpy.gr.spatial_autocorr` conveniently wraps two
spatial autocorrelation statistics: *Moran's I* and *Geary's C*.
They provide a score on the degree of spatial variability of gene expression.
The statistic as well as the p-value are computed for each gene, and FDR correction
is performed. For the purpose of this tutorial, let's compute the *Moran's I* score.
See :ref:`sphx_glr_auto_examples_graph_compute_moran.py` for more details.

.. GENERATED FROM PYTHON SOURCE LINES 88-93

.. code-block:: default


    adata.var_names_make_unique()
    sq.gr.spatial_autocorr(adata, mode="moran")
    adata.uns["moranI"].head(10)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>I</th>
          <th>pval_norm</th>
          <th>var_norm</th>
          <th>pval_norm_fdr_bh</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Yap/Taz</th>
          <td>0.972983</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>CRT</th>
          <td>0.958549</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>TUBA1A</th>
          <td>0.939637</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>NUPS</th>
          <td>0.915156</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>TFRC</th>
          <td>0.895783</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>HSP60</th>
          <td>0.889377</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Actin</th>
          <td>0.879236</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>CTNNB1</th>
          <td>0.876452</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Climp63</th>
          <td>0.873857</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>VINC</th>
          <td>0.862498</td>
          <td>0.0</td>
          <td>0.000001</td>
          <td>0.0</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 94-96

The results are stored in `adata.uns['moranI']` and we can visualize selected genes
with :func:`scanpy.pl.spatial`.

.. GENERATED FROM PYTHON SOURCE LINES 96-98

.. code-block:: default


    sc.pl.spatial(adata, color="Yap/Taz", spot_size=1)



.. image:: /auto_tutorials/images/sphx_glr_tutorial_fouri_004.png
    :alt: Yap/Taz
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  41.937 seconds)

**Estimated memory usage:**  1257 MB


.. _sphx_glr_download_auto_tutorials_tutorial_fouri.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_fouri.py <tutorial_fouri.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_fouri.ipynb <tutorial_fouri.ipynb>`
